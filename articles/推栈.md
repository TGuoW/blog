# 堆栈

1. 基本类型：Null, Undefined, Boolean, Number, String, Symbol。基本类型保存在栈中，按值访问，在内存中占有固定的空间。

2. 引用类型：Array, Object。引用类型保存在堆中，栈中保存的是它的内存地址。读取这种类型的变量时，先从栈中读取它的内存地址，再通过内存地址去读取到堆中的值。

问题1：

	var a = 20;
	var b = a;
	b = 30;
	
	// 这时a的值是多少？
问题2：

	var a = { name: '前端开发' }
	var b = a;
	b.name = '进阶';
	
	// 这时a.name的值是多少
问题3：

	var a = { name: '前端开发' }
	var b = a;
	a = null;
	
	// 这时b的值是多少
现在来解答一下，三个问题的答案分别是20、‘进阶’、{ name: '前端开发' }

对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。

对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改b.name的值后，相应的a.name也就发生了改变。

对于问题3，首先要说明的是null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。
内存空间管理

JavaScript的内存生命周期是

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放、归还

JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。

思考题

	var a = {n: 1};
	var b = a;
	a.x = a = {n: 2};
	
	a.x     // 这时 a.x 的值是多少
	b.x     // 这时 b.x 的值是多少